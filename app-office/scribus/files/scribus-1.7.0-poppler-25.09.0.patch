Index: Scribus/scribus/plugins/import/pdf/slaoutput.cpp
===================================================================
--- Scribus/scribus/plugins/import/pdf/slaoutput.cpp	(revision 27004)
+++ Scribus/scribus/plugins/import/pdf/slaoutput.cpp	(revision 27005)
@@ -1364,7 +1364,11 @@
 	m_graphicStack.restore();
 }
 
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+void SlaOutputDev::beginTransparencyGroup(GfxState *state, const std::array<double, 4>& bbox, GfxColorSpace * /*blendingColorSpace*/, bool isolated, bool knockout, bool forSoftMask)
+#else
 void SlaOutputDev::beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool isolated, bool knockout, bool forSoftMask)
+#endif
 {
 // 	qDebug() << "SlaOutputDev::beginTransparencyGroup isolated:" << isolated << "knockout:" << knockout << "forSoftMask:" << forSoftMask;
 	pushGroup("", forSoftMask);
@@ -1371,7 +1375,11 @@
 	m_groupStack.top().isolated = isolated;
 }
 
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+void SlaOutputDev::paintTransparencyGroup(GfxState *state, const std::array<double, 4>& bbox)
+#else
 void SlaOutputDev::paintTransparencyGroup(GfxState *state, const double *bbox)
+#endif
 {
 // 	qDebug() << "SlaOutputDev::paintTransparencyGroup";
 	if (m_groupStack.count() != 0)
@@ -1470,7 +1478,11 @@
 	m_tmpSel->clear();
 }
 
-void SlaOutputDev::setSoftMask(GfxState * /*state*/, const double * bbox, bool alpha, Function *transferFunc, GfxColor * /*backdropColor*/)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+void SlaOutputDev::setSoftMask(GfxState* /*state*/, const std::array<double, 4>& bbox, bool alpha, Function* transferFunc, GfxColor* /*backdropColor*/)
+#else
+void SlaOutputDev::setSoftMask(GfxState* /*state*/, const double* bbox, bool alpha, Function* transferFunc, GfxColor* /*backdropColor*/)
+#endif
 {
 	if (m_groupStack.count() <= 0)
 		return;
@@ -2225,11 +2237,20 @@
 	return true;
 }
 
-bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx * /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx* /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const std::array<double, 6>& mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
+#else
+bool SlaOutputDev::tilingPatternFill(GfxState *state, Gfx* /*gfx*/, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep)
+#endif
 {
 //	qDebug() << "SlaOutputDev::tilingPatternFill";
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+	const std::array<double, 4>& bbox = tPat->getBBox();
+	const std::array<double, 6>& pmat = tPat->getMatrix();
+#else
 	const double *bbox = tPat->getBBox();
 	const double *pmat = tPat->getMatrix();
+#endif
 	Dict *resDict = tPat->getResDict();
 
 	PDFRectangle box;
@@ -3641,7 +3662,11 @@
 		return CommonStrings::None;
 	if (color->getSpace() == AnnotColor::colorRGB)
 	{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+		const std::array<double, 4>& color_data = color->getValues();
+#else
 		const double *color_data = color->getValues();
+#endif
 		double Rc = color_data[0];
 		double Gc = color_data[1];
 		double Bc = color_data[2];
@@ -3650,7 +3675,11 @@
 	}
 	else if (color->getSpace() == AnnotColor::colorCMYK)
 	{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+		const std::array<double, 4>& color_data = color->getValues();
+#else
 		const double *color_data = color->getValues();
+#endif
 		double Cc = color_data[0];
 		double Mc = color_data[1];
 		double Yc = color_data[2];
@@ -3660,7 +3689,11 @@
 	}
 	else if (color->getSpace() == AnnotColor::colorGray)
 	{
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+		const std::array<double, 4>& color_data = color->getValues();
+#else
 		const double *color_data = color->getValues();
+#endif
 		double Kc = 1.0 - color_data[0];
 		tmp.setCmykColorF(0, 0, 0, Kc);
 		fNam = m_doc->PageColors.tryAddColor(namPrefix+tmp.name(), tmp);
Index: Scribus/scribus/plugins/import/pdf/slaoutput.h
===================================================================
--- Scribus/scribus/plugins/import/pdf/slaoutput.h	(revision 27004)
+++ Scribus/scribus/plugins/import/pdf/slaoutput.h	(revision 27005)
@@ -20,6 +20,7 @@
 #include <QTextStream>
 #include <QTransform>
 
+#include <array>
 #include <memory>
 
 #include "fpointarray.h"
@@ -195,7 +196,12 @@
 	void stroke(GfxState *state) override;
 	void fill(GfxState *state) override;
 	void eoFill(GfxState *state) override;
+
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, GfxTilingPattern *tPat, const std::array<double, 6>& mat, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
+#else
 	bool tilingPatternFill(GfxState *state, Gfx *gfx, Catalog *cat, GfxTilingPattern *tPat, const double *mat, int x0, int y0, int x1, int y1, double xStep, double yStep) override;
+#endif
 	bool functionShadedFill(GfxState * /*state*/, GfxFunctionShading * /*shading*/) override { qDebug() << "Function Shaded Fill";  return false; }
 	bool axialShadedFill(GfxState *state, GfxAxialShading *shading, double tMin, double tMax) override;
 	bool axialShadedSupportExtend(GfxState *state, GfxAxialShading *shading)  override { return (shading->getExtend0() == shading->getExtend1()); }
@@ -254,10 +260,20 @@
 				   bool maskInvert, bool maskInterpolate) override;
 
 	//----- transparency groups and soft masks
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+	void beginTransparencyGroup(GfxState *state, const std::array<double, 4>& bbox, GfxColorSpace* /*blendingColorSpace*/, bool /*isolated*/, bool /*knockout*/, bool /*forSoftMask*/) override;
+	void paintTransparencyGroup(GfxState *state, const std::array<double, 4>& bbox) override;
+#else
 	void beginTransparencyGroup(GfxState *state, const double *bbox, GfxColorSpace * /*blendingColorSpace*/, bool /*isolated*/, bool /*knockout*/, bool /*forSoftMask*/) override;
 	void paintTransparencyGroup(GfxState *state, const double *bbox) override;
+#endif
 	void endTransparencyGroup(GfxState *state) override;
+
+#if POPPLER_ENCODED_VERSION >= POPPLER_VERSION_ENCODE(25, 9, 0)
+	void setSoftMask(GfxState * /*state*/, const std::array<double, 4> & /*bbox*/, bool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
+#else
 	void setSoftMask(GfxState * /*state*/, const double * /*bbox*/, bool /*alpha*/, Function * /*transferFunc*/, GfxColor * /*backdropColor*/) override;
+#endif
 	void clearSoftMask(GfxState * /*state*/) override;
 
 	void updateFillColor(GfxState *state) override;
